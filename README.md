# Factorio SAT
Enhancing the Factorio experience with SAT solvers.

![](/pictures/diagram.png)

## How it works
 * A balancer size is selected. 
 * Tiles get represented as a list of boolean (true/false) variables (input direction, output direction, splitterness, etc).
 * The rules for connecting the tiles are written as boolean clauses (e.g. If tile A points into tile B then the inputs/outputs must connect)
 * Every belt has a colour that corresponds to an edge on the belt balancer network
 * More clauses are added so that only splitters exist on the belt balancer network are allowed
 * Clauses are passed into a solver which determines whether a solution exists
 * If no solution is found then a new size is selected

## Caveats
 * The balancers created do not have perfect throughput, given the right network as input perfect throughput balancers can be generated
 * Currently the assumption that splitters that are directly connected to the inputs/outputs are placed next to the input/output
 * I don't have a proof that the clauses generated by the program are consistent with the rules of Factorio
 * This problem gets exponentially harder as more splitters are added to the network. At least until someone proves P = NP

## Setup
```bash
# Install dependencies
python -m pip install -r requirements.txt

# Get textures
cd assets
python fetch.py /path/to/factorio/install

# Factorio install directory should look something like:
# Factorio/
# ├── bin/
# ├── data/
# │   ├── base/
# │   ├── core/
# │   ...
# ...
```

## Tools

| Tool                 | Usage                                  |
| -------------------- | -------------------------------------- |
| fetch.py             | Load textures (required for render.py) |
| blueprint.py         | Import/Export blueprints               |
| blueprint_book.py    | Pack/Unpack blueprint books            |
| render.py            | Render generated balancers             |
| network.py           | Tools for managing balancer networks   |
| belt_balancer.py     | Generate balancer from a network       |
| make_block.py        | Generate random blocks of belts        |
| calculate_optimal.py | Find optimal balancers                 |
| rotate.py            | Rotate a balancer 90 degrees           |
| stringifier.py       | Convert balancers to and from text     |
| test_runner.py       | Run the test suite                     |

## Controls (render.py)
| Key | Usage                          |
| --- | ------------------------------ |
| I   | Go to next                     |
| K   | Go to previous                 |
| S   | Save animation of balancer     |
| E   | Export balancer as a blueprint |

## Example Usages
```bash
# Render optimal area balancers with maximum underground length 4
python calculate_optimal.py query 4 area | python render.py

# Start computing the optimal by length with maximum underground length of 16
python calculate_optimal.py compute 16 length

# Render a network graph
python network.py render networks/5x5 5_to_5.png

# Save an animation of a blueprint to a file
cat blueprint.txt | python blueprint.py decode | python render.py --export-all

# Generate 50 random blocks and save to a blueprint book
python make_block.py 16 16 --all --single-loop | head -n 50 | python blueprint.py encode | python blueprint_book.py pack --label "Blocks" > blueprint_book.txt
```

## TODO
 * Solve the remaining balancers (8 to 7, 7 to 5, 5 to 7, 8 to 5, 7 to 8, 5 to 8)
 * Go bigger
 * Find the optimal interchanges for larger balancers
 * Add support for finding the optimal factory units

## Examples
![](/pictures/2to3.gif)
![](/pictures/6to7.gif)\
![](/pictures/block.gif)
